/* node가 장비제어도 가능해서 범용어 - 로봇도 제어하고, 임베디드장비 웹프로그램도 가능
디비도 접근할 수 있고 

node로 롯보트를 제어한다면 필요한 연산자가 비트 연산자이다. 
비트 연산자 : &(and연산), |(or연산), ~(not연산)
논리연산자는 전체 수식을 true 또는 false로 파악하여 true && false로 연산한다 
비트연산자는 주어진 값들을 이진수로 바꾸어서 각각의 비트끼리 연산을 수행한다. 
예) 
   a = 7;
   b = 4; 

   a && b => a가 0이 아니고 b가 영이 아니면으로 판단한다. 즉 a에7이 있으니까 true이고 
             b에 4가 있으니까 true 
             true && true 라 true로 판단한다. 

   a & b일때          0000 0111    : <- 7임 
                      0000 0100    : <-4임
                 -------------------------
                     0000 0100    : 결과 4임 

            211.102.01.12
            255.355.255.0    A,B,C 네트워크 ip 가 211.102.01      
*/
// 0000 0000  0000 0000  0000 0000 0000 0001

// 4 - 3 => 4 + (-3) 으로 해석해서 연산한다
//-3 -> 3의 2의 보수를 구한다.   0111 -> 1000 -> 1001
/*
   반가산기 (반쪽 덧셈)

   입력데이터            비트에대한 덧셈   올림수
   0              0         0          0
   0              1         1          0
   1              0         1          0
   1              1         0          1
   ------------------- 
   덧셈 : xor 서로 다를때 1이고 같을때 0 
   s = A xor B 
   c = A and B 

    4 - 3 => 4 + (-3) 뺄셈기를 만드는 비용이 3의 -표현하는것 보다 돈이 더든다. 

    0000 0100 
    1111 1011
    ----------
           +1
    -----------
    1111 1100    

    00000001    00000010    00000011  00000000
    
              1 11111  123-64 =   123 = 64 + 32+ 16 + 2+1 
                                                      
    00000000    00000000   00000000   1110011
*/
//console.log( a + b);

//shift 연산자 <<, >>  -- 비트를 이동시킨다. 방향에 따라 왼쪽으로 또는 오른쪽으로 이동시킨다
/*
 2 << 2                0000 0010 
                     0000 001000
                ---------------------
                        0000 1000
 2 ** 2 
 2 >> 2    2/4

*/
let a = 0b110010;
console.log( a );
a = 0o777;  //8진수
console.log( a );
a =0xff;
console.log( a );

console.log( a ^ 0xff );  // ^ xor 연산자- 배타적 or연산자 서로 값이 다를때 1이다. 
console.log( a ^ 0x00 );  //  같을때 0  0xff ^ 0xff -> 0
// HashMap 궁금해요?             
